2021-06-04 19:20:06:620 grammar LogManager.java:25 before: (COMBINED_GRAMMAR miniPascalLang (@ header {
	import data_structure.PascalSymbol;
	import data_structure.PascalVariable;
	import data_structure.PascalSymbolTable;
	import exceptions.PascalSemanticException;
	import java.util.ArrayList;

}) (@ members {
	private int _tipo;
	private String _varName;
	private String _varValue;
	private PascalSymbolTable symbolTable = new PascalSymbolTable();
	private PascalSymbol symbol;
	
	public void verifiqueID(String id){
		if(!symbolTable.exists(id)){
			throw new PascalSemanticException("Symbol" +_varName+"already declared");
		}
	}
}) (RULES (RULE programa (BLOCK (ALT PROGRAM ident {verifiqueID(_input.LT(-1).getText()); } SC bloco))) (RULE bloco (BLOCK (ALT (? (BLOCK (ALT partDeclVar))) (? (BLOCK (ALT partDecSubRot))) comandoComposto))) (RULE partDeclVar (BLOCK (ALT declVar (* (BLOCK (ALT SC declVar))) SC))) (RULE declVar (BLOCK (ALT tipo listIdent))) (RULE listIdent (BLOCK (ALT ident {
										_varName = _input.LT(-1).getText();
										_varValue = null;
										symbol = new PascalVariable(_varName,_tipo, _varValue);
										if(!symbolTable.exists(_varName)){
											symbolTable.add(symbol);
										}else {
											throw new PascalSemanticException("Symbol"+ _varName+"already declared");
										}
										} (* (BLOCK (ALT V ident { 
										_varName = _input.LT(-1).getText();
										_varValue = null;
										symbol = new PascalVariable(_varName,_tipo, _varValue);
										if(!symbolTable.exists(_varName)){
											symbolTable.add(symbol);
										}else {
											throw new PascalSemanticException("Symbol"+ _varName+"already declared");
										}
								})))))) (RULE partDecSubRot (BLOCK (ALT (* (BLOCK (ALT declProced SC)))))) (RULE declProced (BLOCK (ALT 'procedure' ident {verifiqueID(_input.LT(-1).getText()); } (? (BLOCK (ALT paramFormais))) SC bloco))) (RULE paramFormais (BLOCK (ALT OP secParamFormais (* (BLOCK (ALT SC secParamFormais))) CP))) (RULE secParamFormais (BLOCK (ALT (? (BLOCK (ALT VAR))) listIdent TD ident { verifiqueID(_input.LT(-1).getText()); }))) (RULE comando (BLOCK (ALT atribuicao) (ALT chamadaProcedimento) (ALT comandoComposto) (ALT comandoCondicional) (ALT comandoRepetitivo))) (RULE comandoComposto (BLOCK (ALT BEGIN comando (* (BLOCK (ALT SC comando))) END {System.out.println("Comando composto reconhecido!");}))) (RULE atribuicao (BLOCK (ALT variavel TDE expressao {System.out.println("Comando atribuição reconhecido!");}))) (RULE chamadaProcedimento (BLOCK (ALT ident {verifiqueID(_input.LT(-1).getText());} (? (BLOCK (ALT OP listExpressoes CP))) {System.out.println("Comando chamada de procedimento reconhecido!");}))) (RULE comandoCondicional (BLOCK (ALT IF expressao THEN comando (? (BLOCK (ALT ELSE comando))) {System.out.println("Comando condicional reconhecido!");}))) (RULE comandoRepetitivo (BLOCK (ALT WHILE expressao DO comando {System.out.println("Comando repetitivo reconhecido!")}))) (RULE expressao (BLOCK (ALT expressaoSimples (? (BLOCK (ALT relacao expressaoSimples)))))) (RULE relacao (BLOCK (ALT Operacao))) (RULE expressaoSimples (BLOCK (ALT (? (BLOCK (ALT MAIS) (ALT MENOS))) termo (* (BLOCK (ALT (BLOCK (ALT MAIS) (ALT MENOS) (ALT OR)) termo)))))) (RULE termo (BLOCK (ALT fator (* (BLOCK (ALT (BLOCK (ALT VEZES) (ALT DIV) (ALT AND)) fator)))))) (RULE fator (BLOCK (ALT variavel) (ALT numero) (ALT OP expressao CP) (ALT NOT fator))) (RULE variavel (BLOCK (ALT ident {verifiqueID(_input.LT(-1).getText());}) (ALT ident {verifiqueID(_input.LT(-1).getText()); } (? (BLOCK (ALT expressao)))))) (RULE listExpressoes (BLOCK (ALT expressao (* (BLOCK (ALT V expressao)))))) (RULE numero (BLOCK (ALT Digitos (* (BLOCK (ALT Digitos)))))) (RULE ident (BLOCK (ALT Letras (* (BLOCK (ALT Letras) (ALT Digitos)))))) (RULE tipo (BLOCK (ALT INTEGER {_tipo = PascalVariable.INTEGER;}) (ALT REAL {_tipo = PascalVariable.REAL;}) (ALT BOOLEAN {_tipo = PascalVariable.BOOLEAN;}) (ALT STRING {_tipo = PascalVariable.STRING;}))) (RULE PROGRAM (BLOCK (ALT 'program'))) (RULE INTEGER (BLOCK (ALT 'integer'))) (RULE REAL (BLOCK (ALT 'real'))) (RULE BOOLEAN (BLOCK (ALT 'boolean'))) (RULE CHAR (BLOCK (ALT 'char'))) (RULE STRING (BLOCK (ALT 'string'))) (RULE Operacao (BLOCK (ALT '=') (ALT '<>') (ALT '<') (ALT '<=') (ALT '>=') (ALT '>'))) (RULE MAIS (BLOCK (ALT '+'))) (RULE MENOS (BLOCK (ALT '-'))) (RULE OR (BLOCK (ALT 'or'))) (RULE VEZES (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT 'div'))) (RULE AND (BLOCK (ALT 'and'))) (RULE Digitos (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE Letras (BLOCK (ALT [a-z]) (ALT [A-Z] (* (BLOCK (ALT [a-z]) (ALT [A-Z]) (ALT [0-9])))))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE SC (BLOCK (ALT ';'))) (RULE V (BLOCK (ALT ','))) (RULE VAR (BLOCK (ALT 'var'))) (RULE OP (BLOCK (ALT '('))) (RULE CP (BLOCK (ALT ')'))) (RULE TD (BLOCK (ALT ':'))) (RULE TDE (BLOCK (ALT ':='))) (RULE NOT (BLOCK (ALT 'not'))) (RULE WS (BLOCK (LEXER_ALT_ACTION (ALT (BLOCK (ALT ' ') (ALT '\n') (ALT '\t') (ALT '\r') (ALT '//') (ALT '{ }'))) skip))) (RULE BEGIN (BLOCK (ALT 'begin'))) (RULE END (BLOCK (ALT 'end'))) (RULE IF (BLOCK (ALT 'if'))) (RULE THEN (BLOCK (ALT 'then'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE DO (BLOCK (ALT 'do')))))
2021-06-04 19:20:06:646 grammar LogManager.java:25 after: (COMBINED_GRAMMAR miniPascalLang (@ header {
	import data_structure.PascalSymbol;
	import data_structure.PascalVariable;
	import data_structure.PascalSymbolTable;
	import exceptions.PascalSemanticException;
	import java.util.ArrayList;

}) (@ members {
	private int _tipo;
	private String _varName;
	private String _varValue;
	private PascalSymbolTable symbolTable = new PascalSymbolTable();
	private PascalSymbol symbol;
	
	public void verifiqueID(String id){
		if(!symbolTable.exists(id)){
			throw new PascalSemanticException("Symbol" +_varName+"already declared");
		}
	}
}) (RULES (RULE programa (BLOCK (ALT PROGRAM ident {verifiqueID(_input.LT(-1).getText()); } SC bloco))) (RULE bloco (BLOCK (ALT (? (BLOCK (ALT partDeclVar))) (? (BLOCK (ALT partDecSubRot))) comandoComposto))) (RULE partDeclVar (BLOCK (ALT declVar (* (BLOCK (ALT SC declVar))) SC))) (RULE declVar (BLOCK (ALT tipo listIdent))) (RULE listIdent (BLOCK (ALT ident {
										_varName = _input.LT(-1).getText();
										_varValue = null;
										symbol = new PascalVariable(_varName,_tipo, _varValue);
										if(!symbolTable.exists(_varName)){
											symbolTable.add(symbol);
										}else {
											throw new PascalSemanticException("Symbol"+ _varName+"already declared");
										}
										} (* (BLOCK (ALT V ident { 
										_varName = _input.LT(-1).getText();
										_varValue = null;
										symbol = new PascalVariable(_varName,_tipo, _varValue);
										if(!symbolTable.exists(_varName)){
											symbolTable.add(symbol);
										}else {
											throw new PascalSemanticException("Symbol"+ _varName+"already declared");
										}
								})))))) (RULE partDecSubRot (BLOCK (ALT (* (BLOCK (ALT declProced SC)))))) (RULE declProced (BLOCK (ALT 'procedure' ident {verifiqueID(_input.LT(-1).getText()); } (? (BLOCK (ALT paramFormais))) SC bloco))) (RULE paramFormais (BLOCK (ALT OP secParamFormais (* (BLOCK (ALT SC secParamFormais))) CP))) (RULE secParamFormais (BLOCK (ALT (? (BLOCK (ALT VAR))) listIdent TD ident { verifiqueID(_input.LT(-1).getText()); }))) (RULE comando (BLOCK (ALT atribuicao) (ALT chamadaProcedimento) (ALT comandoComposto) (ALT comandoCondicional) (ALT comandoRepetitivo))) (RULE comandoComposto (BLOCK (ALT BEGIN comando (* (BLOCK (ALT SC comando))) END {System.out.println("Comando composto reconhecido!");}))) (RULE atribuicao (BLOCK (ALT variavel TDE expressao {System.out.println("Comando atribuição reconhecido!");}))) (RULE chamadaProcedimento (BLOCK (ALT ident {verifiqueID(_input.LT(-1).getText());} (? (BLOCK (ALT OP listExpressoes CP))) {System.out.println("Comando chamada de procedimento reconhecido!");}))) (RULE comandoCondicional (BLOCK (ALT IF expressao THEN comando (? (BLOCK (ALT ELSE comando))) {System.out.println("Comando condicional reconhecido!");}))) (RULE comandoRepetitivo (BLOCK (ALT WHILE expressao DO comando {System.out.println("Comando repetitivo reconhecido!")}))) (RULE expressao (BLOCK (ALT expressaoSimples (? (BLOCK (ALT relacao expressaoSimples)))))) (RULE relacao (BLOCK (ALT Operacao))) (RULE expressaoSimples (BLOCK (ALT (? (BLOCK (ALT (SET MAIS MENOS)))) termo (* (BLOCK (ALT (SET MAIS MENOS OR) termo)))))) (RULE termo (BLOCK (ALT fator (* (BLOCK (ALT (SET VEZES DIV AND) fator)))))) (RULE fator (BLOCK (ALT variavel) (ALT numero) (ALT OP expressao CP) (ALT NOT fator))) (RULE variavel (BLOCK (ALT ident {verifiqueID(_input.LT(-1).getText());}) (ALT ident {verifiqueID(_input.LT(-1).getText()); } (? (BLOCK (ALT expressao)))))) (RULE listExpressoes (BLOCK (ALT expressao (* (BLOCK (ALT V expressao)))))) (RULE numero (BLOCK (ALT Digitos (* (BLOCK (ALT Digitos)))))) (RULE ident (BLOCK (ALT Letras (* (BLOCK (ALT (SET Letras Digitos))))))) (RULE tipo (BLOCK (ALT INTEGER {_tipo = PascalVariable.INTEGER;}) (ALT REAL {_tipo = PascalVariable.REAL;}) (ALT BOOLEAN {_tipo = PascalVariable.BOOLEAN;}) (ALT STRING {_tipo = PascalVariable.STRING;}))) (RULE PROGRAM (BLOCK (ALT 'program'))) (RULE INTEGER (BLOCK (ALT 'integer'))) (RULE REAL (BLOCK (ALT 'real'))) (RULE BOOLEAN (BLOCK (ALT 'boolean'))) (RULE CHAR (BLOCK (ALT 'char'))) (RULE STRING (BLOCK (ALT 'string'))) (RULE Operacao (BLOCK (ALT '=') (ALT '<>') (ALT '<') (ALT '<=') (ALT '>=') (ALT '>'))) (RULE MAIS (BLOCK (ALT '+'))) (RULE MENOS (BLOCK (ALT '-'))) (RULE OR (BLOCK (ALT 'or'))) (RULE VEZES (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT 'div'))) (RULE AND (BLOCK (ALT 'and'))) (RULE Digitos (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE Letras (BLOCK (ALT [a-z]) (ALT [A-Z] (* (BLOCK (ALT [a-z]) (ALT [A-Z]) (ALT [0-9])))))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE SC (BLOCK (ALT ';'))) (RULE V (BLOCK (ALT ','))) (RULE VAR (BLOCK (ALT 'var'))) (RULE OP (BLOCK (ALT '('))) (RULE CP (BLOCK (ALT ')'))) (RULE TD (BLOCK (ALT ':'))) (RULE TDE (BLOCK (ALT ':='))) (RULE NOT (BLOCK (ALT 'not'))) (RULE WS (BLOCK (LEXER_ALT_ACTION (ALT (BLOCK (ALT ' ') (ALT '\n') (ALT '\t') (ALT '\r') (ALT '//') (ALT '{ }'))) skip))) (RULE BEGIN (BLOCK (ALT 'begin'))) (RULE END (BLOCK (ALT 'end'))) (RULE IF (BLOCK (ALT 'if'))) (RULE THEN (BLOCK (ALT 'then'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE DO (BLOCK (ALT 'do')))))
2021-06-04 19:20:06:679 grammar LogManager.java:25 after extract implicit lexer =(COMBINED_GRAMMAR miniPascalLang (@ header {
	import data_structure.PascalSymbol;
	import data_structure.PascalVariable;
	import data_structure.PascalSymbolTable;
	import exceptions.PascalSemanticException;
	import java.util.ArrayList;

}) (@ members {
	private int _tipo;
	private String _varName;
	private String _varValue;
	private PascalSymbolTable symbolTable = new PascalSymbolTable();
	private PascalSymbol symbol;
	
	public void verifiqueID(String id){
		if(!symbolTable.exists(id)){
			throw new PascalSemanticException("Symbol" +_varName+"already declared");
		}
	}
}) (RULES (RULE programa (BLOCK (ALT PROGRAM ident {verifiqueID(_input.LT(-1).getText()); } SC bloco))) (RULE bloco (BLOCK (ALT (? (BLOCK (ALT partDeclVar))) (? (BLOCK (ALT partDecSubRot))) comandoComposto))) (RULE partDeclVar (BLOCK (ALT declVar (* (BLOCK (ALT SC declVar))) SC))) (RULE declVar (BLOCK (ALT tipo listIdent))) (RULE listIdent (BLOCK (ALT ident {
										_varName = _input.LT(-1).getText();
										_varValue = null;
										symbol = new PascalVariable(_varName,_tipo, _varValue);
										if(!symbolTable.exists(_varName)){
											symbolTable.add(symbol);
										}else {
											throw new PascalSemanticException("Symbol"+ _varName+"already declared");
										}
										} (* (BLOCK (ALT V ident { 
										_varName = _input.LT(-1).getText();
										_varValue = null;
										symbol = new PascalVariable(_varName,_tipo, _varValue);
										if(!symbolTable.exists(_varName)){
											symbolTable.add(symbol);
										}else {
											throw new PascalSemanticException("Symbol"+ _varName+"already declared");
										}
								})))))) (RULE partDecSubRot (BLOCK (ALT (* (BLOCK (ALT declProced SC)))))) (RULE declProced (BLOCK (ALT 'procedure' ident {verifiqueID(_input.LT(-1).getText()); } (? (BLOCK (ALT paramFormais))) SC bloco))) (RULE paramFormais (BLOCK (ALT OP secParamFormais (* (BLOCK (ALT SC secParamFormais))) CP))) (RULE secParamFormais (BLOCK (ALT (? (BLOCK (ALT VAR))) listIdent TD ident { verifiqueID(_input.LT(-1).getText()); }))) (RULE comando (BLOCK (ALT atribuicao) (ALT chamadaProcedimento) (ALT comandoComposto) (ALT comandoCondicional) (ALT comandoRepetitivo))) (RULE comandoComposto (BLOCK (ALT BEGIN comando (* (BLOCK (ALT SC comando))) END {System.out.println("Comando composto reconhecido!");}))) (RULE atribuicao (BLOCK (ALT variavel TDE expressao {System.out.println("Comando atribuição reconhecido!");}))) (RULE chamadaProcedimento (BLOCK (ALT ident {verifiqueID(_input.LT(-1).getText());} (? (BLOCK (ALT OP listExpressoes CP))) {System.out.println("Comando chamada de procedimento reconhecido!");}))) (RULE comandoCondicional (BLOCK (ALT IF expressao THEN comando (? (BLOCK (ALT ELSE comando))) {System.out.println("Comando condicional reconhecido!");}))) (RULE comandoRepetitivo (BLOCK (ALT WHILE expressao DO comando {System.out.println("Comando repetitivo reconhecido!")}))) (RULE expressao (BLOCK (ALT expressaoSimples (? (BLOCK (ALT relacao expressaoSimples)))))) (RULE relacao (BLOCK (ALT Operacao))) (RULE expressaoSimples (BLOCK (ALT (? (BLOCK (ALT (SET MAIS MENOS)))) termo (* (BLOCK (ALT (SET MAIS MENOS OR) termo)))))) (RULE termo (BLOCK (ALT fator (* (BLOCK (ALT (SET VEZES DIV AND) fator)))))) (RULE fator (BLOCK (ALT variavel) (ALT numero) (ALT OP expressao CP) (ALT NOT fator))) (RULE variavel (BLOCK (ALT ident {verifiqueID(_input.LT(-1).getText());}) (ALT ident {verifiqueID(_input.LT(-1).getText()); } (? (BLOCK (ALT expressao)))))) (RULE listExpressoes (BLOCK (ALT expressao (* (BLOCK (ALT V expressao)))))) (RULE numero (BLOCK (ALT Digitos (* (BLOCK (ALT Digitos)))))) (RULE ident (BLOCK (ALT Letras (* (BLOCK (ALT (SET Letras Digitos))))))) (RULE tipo (BLOCK (ALT INTEGER {_tipo = PascalVariable.INTEGER;}) (ALT REAL {_tipo = PascalVariable.REAL;}) (ALT BOOLEAN {_tipo = PascalVariable.BOOLEAN;}) (ALT STRING {_tipo = PascalVariable.STRING;})))))
2021-06-04 19:20:06:679 grammar LogManager.java:25 lexer =(LEXER_GRAMMAR miniPascalLangLexer (@ header {
	import data_structure.PascalSymbol;
	import data_structure.PascalVariable;
	import data_structure.PascalSymbolTable;
	import exceptions.PascalSemanticException;
	import java.util.ArrayList;

}) (@ members {
	private int _tipo;
	private String _varName;
	private String _varValue;
	private PascalSymbolTable symbolTable = new PascalSymbolTable();
	private PascalSymbol symbol;
	
	public void verifiqueID(String id){
		if(!symbolTable.exists(id)){
			throw new PascalSemanticException("Symbol" +_varName+"already declared");
		}
	}
}) (RULES (RULE T__0 (BLOCK (ALT 'procedure'))) (RULE PROGRAM (BLOCK (ALT 'program'))) (RULE INTEGER (BLOCK (ALT 'integer'))) (RULE REAL (BLOCK (ALT 'real'))) (RULE BOOLEAN (BLOCK (ALT 'boolean'))) (RULE CHAR (BLOCK (ALT 'char'))) (RULE STRING (BLOCK (ALT 'string'))) (RULE Operacao (BLOCK (ALT '=') (ALT '<>') (ALT '<') (ALT '<=') (ALT '>=') (ALT '>'))) (RULE MAIS (BLOCK (ALT '+'))) (RULE MENOS (BLOCK (ALT '-'))) (RULE OR (BLOCK (ALT 'or'))) (RULE VEZES (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT 'div'))) (RULE AND (BLOCK (ALT 'and'))) (RULE Digitos (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE Letras (BLOCK (ALT [a-z]) (ALT [A-Z] (* (BLOCK (ALT [a-z]) (ALT [A-Z]) (ALT [0-9])))))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE SC (BLOCK (ALT ';'))) (RULE V (BLOCK (ALT ','))) (RULE VAR (BLOCK (ALT 'var'))) (RULE OP (BLOCK (ALT '('))) (RULE CP (BLOCK (ALT ')'))) (RULE TD (BLOCK (ALT ':'))) (RULE TDE (BLOCK (ALT ':='))) (RULE NOT (BLOCK (ALT 'not'))) (RULE WS (BLOCK (LEXER_ALT_ACTION (ALT (BLOCK (ALT ' ') (ALT '\n') (ALT '\t') (ALT '\r') (ALT '//') (ALT '{ }'))) skip))) (RULE BEGIN (BLOCK (ALT 'begin'))) (RULE END (BLOCK (ALT 'end'))) (RULE IF (BLOCK (ALT 'if'))) (RULE THEN (BLOCK (ALT 'then'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE DO (BLOCK (ALT 'do')))))
2021-06-04 19:20:06:883 action-translator LogManager.java:25 translate 
	private int _tipo;
	private String _varName;
	private String _varValue;
	private PascalSymbolTable symbolTable = new PascalSymbolTable();
	private PascalSymbol symbol;
	
	public void verifiqueID(String id){
		if(!symbolTable.exists(id)){
			throw new PascalSemanticException("Symbol" +_varName+"already declared");
		}
	}

2021-06-04 19:20:06:883 action-translator LogManager.java:25 translate 
	import data_structure.PascalSymbol;
	import data_structure.PascalVariable;
	import data_structure.PascalSymbolTable;
	import exceptions.PascalSemanticException;
	import java.util.ArrayList;


2021-06-04 19:20:06:945 semantics LogManager.java:25 tokens={EOF=-1, T__0=1, PROGRAM=2, INTEGER=3, REAL=4, BOOLEAN=5, CHAR=6, STRING=7, Operacao=8, MAIS=9, MENOS=10, OR=11, VEZES=12, DIV=13, AND=14, Digitos=15, Letras=16, TRUE=17, FALSE=18, SC=19, V=20, VAR=21, OP=22, CP=23, TD=24, TDE=25, NOT=26, WS=27, BEGIN=28, END=29, IF=30, THEN=31, ELSE=32, WHILE=33, DO=34}
2021-06-04 19:20:06:945 semantics LogManager.java:25 strings={'procedure'=1, 'program'=2, 'integer'=3, 'real'=4, 'boolean'=5, 'char'=6, 'string'=7, '+'=9, '-'=10, 'or'=11, '*'=12, 'div'=13, 'and'=14, 'true'=17, 'false'=18, ';'=19, ','=20, 'var'=21, '('=22, ')'=23, ':'=24, ':='=25, 'not'=26, 'begin'=28, 'end'=29, 'if'=30, 'then'=31, 'else'=32, 'while'=33, 'do'=34}
2021-06-04 19:20:06:958 LL1 LogManager.java:25 
DECISION 0 in rule bloco
2021-06-04 19:20:06:959 LL1 LogManager.java:25 look=[{3..5, 7}, {1, 28}]
2021-06-04 19:20:06:959 LL1 LogManager.java:25 LL(1)? true
2021-06-04 19:20:06:959 LL1 LogManager.java:25 
DECISION 1 in rule bloco
2021-06-04 19:20:06:959 LL1 LogManager.java:25 look=[{1, 28}, 28]
2021-06-04 19:20:06:959 LL1 LogManager.java:25 LL(1)? false
2021-06-04 19:20:06:959 LL1 LogManager.java:25 
DECISION 2 in rule partDeclVar
2021-06-04 19:20:06:959 LL1 LogManager.java:25 look=[19, 19]
2021-06-04 19:20:06:959 LL1 LogManager.java:25 LL(1)? false
2021-06-04 19:20:06:959 LL1 LogManager.java:25 
DECISION 3 in rule listIdent
2021-06-04 19:20:06:959 LL1 LogManager.java:25 look=[20, {19, 24}]
2021-06-04 19:20:06:959 LL1 LogManager.java:25 LL(1)? true
2021-06-04 19:20:06:959 LL1 LogManager.java:25 
DECISION 4 in rule partDecSubRot
2021-06-04 19:20:06:959 LL1 LogManager.java:25 look=[1, 28]
2021-06-04 19:20:06:959 LL1 LogManager.java:25 LL(1)? true
2021-06-04 19:20:06:959 LL1 LogManager.java:25 
DECISION 5 in rule declProced
2021-06-04 19:20:06:959 LL1 LogManager.java:25 look=[22, 19]
2021-06-04 19:20:06:959 LL1 LogManager.java:25 LL(1)? true
2021-06-04 19:20:06:959 LL1 LogManager.java:25 
DECISION 6 in rule paramFormais
2021-06-04 19:20:06:959 LL1 LogManager.java:25 look=[19, 23]
2021-06-04 19:20:06:959 LL1 LogManager.java:25 LL(1)? true
2021-06-04 19:20:06:959 LL1 LogManager.java:25 
DECISION 7 in rule secParamFormais
2021-06-04 19:20:06:959 LL1 LogManager.java:25 look=[21, 16]
2021-06-04 19:20:06:959 LL1 LogManager.java:25 LL(1)? true
2021-06-04 19:20:06:959 LL1 LogManager.java:25 
DECISION 8 in rule comando
2021-06-04 19:20:06:959 LL1 LogManager.java:25 look=[16, 16, 28, 30, 33]
2021-06-04 19:20:06:959 LL1 LogManager.java:25 LL(1)? false
2021-06-04 19:20:06:959 LL1 LogManager.java:25 
DECISION 9 in rule comandoComposto
2021-06-04 19:20:06:959 LL1 LogManager.java:25 look=[19, 29]
2021-06-04 19:20:06:959 LL1 LogManager.java:25 LL(1)? true
2021-06-04 19:20:06:959 LL1 LogManager.java:25 
DECISION 10 in rule chamadaProcedimento
2021-06-04 19:20:06:959 LL1 LogManager.java:25 look=[22, {19, 29, 32}]
2021-06-04 19:20:06:959 LL1 LogManager.java:25 LL(1)? true
2021-06-04 19:20:06:959 LL1 LogManager.java:25 
DECISION 11 in rule comandoCondicional
2021-06-04 19:20:06:960 LL1 LogManager.java:25 look=[32, {19, 29, 32}]
2021-06-04 19:20:06:960 LL1 LogManager.java:25 LL(1)? false
2021-06-04 19:20:06:960 LL1 LogManager.java:25 
DECISION 12 in rule expressao
2021-06-04 19:20:06:960 LL1 LogManager.java:25 look=[8, {8..14, 19..20, 23, 25, 29, 31..32, 34}]
2021-06-04 19:20:06:960 LL1 LogManager.java:25 LL(1)? false
2021-06-04 19:20:06:960 LL1 LogManager.java:25 
DECISION 13 in rule expressaoSimples
2021-06-04 19:20:06:960 LL1 LogManager.java:25 look=[{9..10}, {15..16, 22, 26}]
2021-06-04 19:20:06:960 LL1 LogManager.java:25 LL(1)? true
2021-06-04 19:20:06:960 LL1 LogManager.java:25 
DECISION 14 in rule expressaoSimples
2021-06-04 19:20:06:960 LL1 LogManager.java:25 look=[{9..11}, {8..14, 19..20, 23, 25, 29, 31..32, 34}]
2021-06-04 19:20:06:960 LL1 LogManager.java:25 LL(1)? false
2021-06-04 19:20:06:960 LL1 LogManager.java:25 
DECISION 15 in rule termo
2021-06-04 19:20:06:961 LL1 LogManager.java:25 look=[{12..14}, {8..14, 19..20, 23, 25, 29, 31..32, 34}]
2021-06-04 19:20:06:961 LL1 LogManager.java:25 LL(1)? false
2021-06-04 19:20:06:961 LL1 LogManager.java:25 
DECISION 16 in rule fator
2021-06-04 19:20:06:961 LL1 LogManager.java:25 look=[16, 15, 22, 26]
2021-06-04 19:20:06:961 LL1 LogManager.java:25 LL(1)? true
2021-06-04 19:20:06:961 LL1 LogManager.java:25 
DECISION 17 in rule variavel
2021-06-04 19:20:06:961 LL1 LogManager.java:25 look=[{9..10, 15..16, 22, 26}, {8..14, 19..20, 23, 25, 29, 31..32, 34}]
2021-06-04 19:20:06:961 LL1 LogManager.java:25 LL(1)? false
2021-06-04 19:20:06:961 LL1 LogManager.java:25 
DECISION 18 in rule variavel
2021-06-04 19:20:06:961 LL1 LogManager.java:25 look=[16, 16]
2021-06-04 19:20:06:961 LL1 LogManager.java:25 LL(1)? false
2021-06-04 19:20:06:961 LL1 LogManager.java:25 
DECISION 19 in rule listExpressoes
2021-06-04 19:20:06:961 LL1 LogManager.java:25 look=[20, 23]
2021-06-04 19:20:06:961 LL1 LogManager.java:25 LL(1)? true
2021-06-04 19:20:06:961 LL1 LogManager.java:25 
DECISION 20 in rule numero
2021-06-04 19:20:06:962 LL1 LogManager.java:25 look=[15, {8..14, 19..20, 23, 25, 29, 31..32, 34}]
2021-06-04 19:20:06:962 LL1 LogManager.java:25 LL(1)? true
2021-06-04 19:20:06:962 LL1 LogManager.java:25 
DECISION 21 in rule ident
2021-06-04 19:20:06:962 LL1 LogManager.java:25 look=[{15..16}, {8..16, 19..20, 22..26, 29, 31..32, 34}]
2021-06-04 19:20:06:962 LL1 LogManager.java:25 LL(1)? false
2021-06-04 19:20:06:962 LL1 LogManager.java:25 
DECISION 22 in rule tipo
2021-06-04 19:20:06:962 LL1 LogManager.java:25 look=[3, 4, 5, 7]
2021-06-04 19:20:06:962 LL1 LogManager.java:25 LL(1)? true
2021-06-04 19:20:06:963 action-translator LogManager.java:25 translate 
	private int _tipo;
	private String _varName;
	private String _varValue;
	private PascalSymbolTable symbolTable = new PascalSymbolTable();
	private PascalSymbol symbol;
	
	public void verifiqueID(String id){
		if(!symbolTable.exists(id)){
			throw new PascalSemanticException("Symbol" +_varName+"already declared");
		}
	}

2021-06-04 19:20:06:963 action-translator LogManager.java:25 translate 
	import data_structure.PascalSymbol;
	import data_structure.PascalVariable;
	import data_structure.PascalSymbolTable;
	import exceptions.PascalSemanticException;
	import java.util.ArrayList;


2021-06-04 19:20:06:976 action-translator LogManager.java:25 translate verifiqueID(_input.LT(-1).getText()); 
2021-06-04 19:20:06:982 action-translator LogManager.java:25 translate 
										_varName = _input.LT(-1).getText();
										_varValue = null;
										symbol = new PascalVariable(_varName,_tipo, _varValue);
										if(!symbolTable.exists(_varName)){
											symbolTable.add(symbol);
										}else {
											throw new PascalSemanticException("Symbol"+ _varName+"already declared");
										}
										
2021-06-04 19:20:06:982 action-translator LogManager.java:25 translate  
										_varName = _input.LT(-1).getText();
										_varValue = null;
										symbol = new PascalVariable(_varName,_tipo, _varValue);
										if(!symbolTable.exists(_varName)){
											symbolTable.add(symbol);
										}else {
											throw new PascalSemanticException("Symbol"+ _varName+"already declared");
										}
								
2021-06-04 19:20:06:983 action-translator LogManager.java:25 translate verifiqueID(_input.LT(-1).getText()); 
2021-06-04 19:20:06:985 action-translator LogManager.java:25 translate  verifiqueID(_input.LT(-1).getText()); 
2021-06-04 19:20:06:987 action-translator LogManager.java:25 translate System.out.println("Comando composto reconhecido!");
2021-06-04 19:20:06:987 action-translator LogManager.java:25 translate System.out.println("Comando atribuição reconhecido!");
2021-06-04 19:20:06:988 action-translator LogManager.java:25 translate verifiqueID(_input.LT(-1).getText());
2021-06-04 19:20:06:988 action-translator LogManager.java:25 translate System.out.println("Comando chamada de procedimento reconhecido!");
2021-06-04 19:20:06:989 action-translator LogManager.java:25 translate System.out.println("Comando condicional reconhecido!");
2021-06-04 19:20:06:990 action-translator LogManager.java:25 translate System.out.println("Comando repetitivo reconhecido!")
2021-06-04 19:20:06:993 action-translator LogManager.java:25 translate verifiqueID(_input.LT(-1).getText());
2021-06-04 19:20:06:994 action-translator LogManager.java:25 translate verifiqueID(_input.LT(-1).getText()); 
2021-06-04 19:20:06:996 action-translator LogManager.java:25 translate _tipo = PascalVariable.INTEGER;
2021-06-04 19:20:06:996 action-translator LogManager.java:25 translate _tipo = PascalVariable.REAL;
2021-06-04 19:20:06:996 action-translator LogManager.java:25 translate _tipo = PascalVariable.BOOLEAN;
2021-06-04 19:20:06:996 action-translator LogManager.java:25 translate _tipo = PascalVariable.STRING;
2021-06-04 19:20:07:048 action-translator LogManager.java:25 translate 
	private int _tipo;
	private String _varName;
	private String _varValue;
	private PascalSymbolTable symbolTable = new PascalSymbolTable();
	private PascalSymbol symbol;
	
	public void verifiqueID(String id){
		if(!symbolTable.exists(id)){
			throw new PascalSemanticException("Symbol" +_varName+"already declared");
		}
	}

2021-06-04 19:20:07:048 action-translator LogManager.java:25 translate 
	import data_structure.PascalSymbol;
	import data_structure.PascalVariable;
	import data_structure.PascalSymbolTable;
	import exceptions.PascalSemanticException;
	import java.util.ArrayList;


2021-06-04 19:20:07:049 action-translator LogManager.java:25 translate 
	import data_structure.PascalSymbol;
	import data_structure.PascalVariable;
	import data_structure.PascalSymbolTable;
	import exceptions.PascalSemanticException;
	import java.util.ArrayList;


2021-06-04 19:20:07:054 action-translator LogManager.java:25 translate 
	private int _tipo;
	private String _varName;
	private String _varValue;
	private PascalSymbolTable symbolTable = new PascalSymbolTable();
	private PascalSymbol symbol;
	
	public void verifiqueID(String id){
		if(!symbolTable.exists(id)){
			throw new PascalSemanticException("Symbol" +_varName+"already declared");
		}
	}

2021-06-04 19:20:07:054 action-translator LogManager.java:25 translate 
	import data_structure.PascalSymbol;
	import data_structure.PascalVariable;
	import data_structure.PascalSymbolTable;
	import exceptions.PascalSemanticException;
	import java.util.ArrayList;


2021-06-04 19:20:07:054 action-translator LogManager.java:25 translate 
	import data_structure.PascalSymbol;
	import data_structure.PascalVariable;
	import data_structure.PascalSymbolTable;
	import exceptions.PascalSemanticException;
	import java.util.ArrayList;


